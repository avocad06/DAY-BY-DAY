# 4150
"""
처음에 문자열로 접근을 해서 해당 문자열을 다시 정수로 변환해서 계산한 값을 각 수열의 자릿수로 사용하는 방법으로 문제를 접근하여 답을 도출했지만,
형변환 함수가 너무 많아서 90% 채점에서 시간초과가 된 것 같다.

=================================================
구글링 결과

수열을 배열, 리스트로 접근하여 문제에 제시된 수열을 정의하는 함수의 인자를 인덱스로 보고 조건에 따라 배열에 추가하는 접근 방식

1. 수열을 배열로 접근하기 위해 리스트 자료형을 사용한다.
2. 첫 번째(f(1))과 두 번째(f(2)) 수열의 값은 각각 1로 고정된다.
3. 순서를 나타내는 함수의 인자를 인덱스로 활용하기 위해 0번째 인덱스는 고려하지 않는다.
4. 새로운 수열의 값은 이전 인덱스의 값과 이전전 인덱스의 값을 더한 값으로 설정한다.
5. 제약 조건(정답은 1000자리를 넘지 않는다)을 설정하고,
6. 제약에 걸리지 않으면 정상적으로 리스트에 새로운 수열의 값을 추가한다.
"""
""" 
처음 시도한 풀이1.
"""
# a = '1'
# b = '1'
# cnt = 3
# target = int(input())

# while cnt != target:
#     prev = int(a) + int(b)

#     if len(str(prev)) <= 1000:
#         break
#     next = int(a)
#     a = str(prev)
#     b = str(next)
#     cnt += 1
    
# print(int(a) + int(b))

""" 
구글링 풀이2.
"""
# 입력받을 수
N = int(input())

# 수열을 담을 리스트
array = [0, 1, 1]
# 수열을 정의하는 함수의 인자
turn = 3

while True:
    # 새로운 수열의 값
    p = array[turn-2] + array[turn-1]
    
    # 새로 생성되는 수열의 값의 자릿수가 1000자를 넘으면 종료
    if len(str(p)) > 1000 or turn > N:
        break
    
    else:
        array.append(p)
        # 다음 수열로
        turn += 1

print(array[N])
    

